<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cost Estimator - SFCDD</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- D3.js for sunburst chart -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      :root {
        --primary-blue: #017dc3;
        --primary-yellow: #fdb813;
        --primary-green: #8ac73e;
        --navbar-height: 72px;
        --font-size-base: 1rem;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-size: var(--font-size-base);
      }

      #navbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        height: var(--navbar-height);
      }

      main.container-fluid {
        position: fixed;
        top: var(--navbar-height);
        left: 0;
        right: 0;
        bottom: 0;
        height: calc(100vh - var(--navbar-height));
        overflow: hidden;
        padding: 0;
        max-width: 100%;
        box-sizing: border-box;
        display: flex;
      }

      .left-section {
        width: 40%;
        height: 100%;
        overflow: hidden;
        padding: 0; /* Remove padding */
        box-sizing: border-box;
        border-right: 2px solid #dee2e6;
        display: flex;
        flex-direction: column;
      }

      .search-container {
        margin-bottom: 1rem;
        width: 100%;
        position: relative;
        padding: 2rem 2rem 0 2rem; /* Add padding to match right section */
      }

      .search-input-wrapper {
        position: relative;
        width: 100%;
      }

      .search-box {
        width: 100%;
        padding: 0.75rem;
        border: 2px solid var(--primary-blue);
        border-radius: 0.375rem;
        font-size: 1rem;
        transition: all 0.2s;
      }

      .search-box:focus {
        outline: none;
        border-color: var(--primary-yellow);
        box-shadow: 0 0 0 0.25rem rgba(253, 184, 19, 0.25);
      }

      .search-results {
        position: absolute;
        top: 100%; /* Position directly below the search box */
        left: 0;
        right: 0;
        width: 100%;
        background: white;
        border: 2px solid var(--primary-blue);
        border-radius: 0.375rem;
        max-height: 400px;
        overflow-y: auto;
        z-index: 100;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        margin-top: 0.5rem; /* Add spacing between search box and dropdown */
      }

      .search-result-item {
        padding: 0.75rem;
        cursor: pointer;
        border-bottom: 1px solid #e0e0e0;
        transition: background-color 0.2s;
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .search-result-item:hover {
        background-color: var(--faded-yellow);
      }

      .search-result-class {
        font-weight: 600;
        color: var(--primary-blue);
        font-size: 0.75rem;
      }

      .search-result-make {
        font-weight: 500;
        color: #666;
        font-size: 0.75rem;
      }

      .search-result-model {
        font-weight: 600;
        color: #333;
        font-size: 0.85rem;
      }

      .no-results {
        padding: 1rem;
        text-align: center;
        color: #666;
        font-style: italic;
      }

      .right-section {
        width: 60%;
        height: 100%;
        overflow-y: auto;
        padding: 2rem;
        box-sizing: border-box;
        background-color: #f8f9fa;
        display: flex;
        flex-direction: column;
      }

      #sunburst {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0 2rem 2rem 2rem; /* Add padding to match right section */
        box-sizing: border-box;
        overflow: hidden; /* Prevent overflow */
      }

      .sunburst-arc {
        cursor: pointer;
        stroke: #fff;
        stroke-width: 1.5; /* Reduced from 2 */
      }

      .sunburst-arc:hover {
        opacity: 0.8;
      }

      .tooltip {
        position: absolute;
        padding: 8px 10px;
        background: rgba(255, 255, 255, 0.95);
        border: 2px solid var(--primary-blue);
        border-radius: 6px;
        pointer-events: none;
        font-size: 0.75rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s;
        max-width: 420px;
        width: max-content;
        min-width: 160px;
      }

      .tooltip.has-photo {
        width: 420px !important;
        max-width: 420px;
      }

      .tooltip-title {
        font-weight: 700;
        color: var(--primary-blue);
        font-size: 0.85rem;
        margin-bottom: 4px;
        border-bottom: 1.5px solid var(--primary-yellow);
        padding-bottom: 3px;
      }

      .tooltip-description {
        color: #333;
        margin: 4px 0;
        line-height: 1.3;
        font-size: 0.7rem;
      }

      .tooltip-stats {
        display: flex;
        gap: 10px;
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px solid #e0e0e0;
      }

      .tooltip-stat {
        display: flex;
        align-items: center;
        gap: 3px;
      }

      .tooltip-stat-label {
        font-weight: 600;
        color: var(--primary-blue);
        font-size: 0.7rem;
      }

      .tooltip-stat-value {
        color: #666;
        font-size: 0.7rem;
      }

      .tooltip-table {
        width: 100%;
        margin-top: 4px;
        border-collapse: collapse;
        table-layout: auto;
      }

      .tooltip-table tr {
        border-bottom: 1px solid #e0e0e0;
      }

      .tooltip-table tr:last-child {
        border-bottom: none;
      }

      .tooltip-table td {
        padding: 4px 6px;
        font-size: 0.7rem;
      }

      .tooltip-table td:first-child {
        font-weight: 600;
        color: var(--primary-blue);
        text-align: left;
        width: auto;
        white-space: nowrap;
        padding-right: 8px;
      }

      .tooltip-table td:last-child {
        color: #666;
        text-align: right;
        width: auto;
      }

      .equipment-list-title {
        color: var(--primary-blue);
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 1rem;
      }

      .equipment-table-container {
        flex: 1;
        overflow-y: auto;
        background-color: white;
        border-radius: 0.375rem;
        border: 1px solid #dee2e6;
      }

      .equipment-table {
        width: 100%;
        margin-bottom: 0;
        font-size: 0.75rem;
        table-layout: fixed !important;
      }

      .equipment-table col.col-qty {
        width: 11%;
      }

      .equipment-table col.col-class {
        width: 7%;
      }

      .equipment-table col.col-make {
        width: 7%;
      }

      .equipment-table col.col-code {
        width: 7%;
      }

      .equipment-table col.col-model {
        width: 12%;
      }

      .equipment-table col.col-base-rate {
        width: 9%;
      }

      .equipment-table col.col-rate-type {
        width: 8%;
      }

      .equipment-table col.col-factor {
        width: 7%;
      }

      .equipment-table col.col-effective-rate {
        width: 9%;
      }

      .equipment-table col.col-hours {
        width: 8%;
      }

      .equipment-table col.col-total {
        width: 12%;
      }

      .equipment-table thead {
        position: sticky;
        top: 0;
        background-color: var(--primary-blue);
        color: white;
        z-index: 10;
      }

      .equipment-table th {
        padding: 0.5rem 0.5rem; /* Reduced padding */
        font-weight: 600;
        font-size: 0.7rem; /* Reduced font size */
        border-bottom: 2px solid var(--primary-yellow);
        white-space: nowrap;
        text-align: center !important; /* Force center alignment for all headers */
      }

      .equipment-table tbody tr {
        border-bottom: 1px solid #dee2e6;
        transition: background-color 0.2s;
        text-align: center;
      }

      .equipment-table tbody tr:hover {
        background-color: var(--faded-yellow);
      }

      .equipment-table tbody tr:last-child {
        border-bottom: none;
      }

      .equipment-table td {
        padding: 0.5rem 0.25rem; /* Reduced padding */
        font-size: 0.7rem; /* Reduced font size */
        vertical-align: middle;
      }

      /* Right-align dollar value columns */
      .equipment-table td:nth-child(6),  /* Base Rate */
      .equipment-table td:nth-child(9),  /* Effective Rate */
      .equipment-table td:nth-child(11)  /* Total */ {
        text-align: right;
        padding-right: 0.75rem;
      }

      /* Left-align QTY column with matching padding */
      .equipment-table td:nth-child(1) {
        padding-left: 0.75rem;
      }

      /* Align column headers to match */
      .equipment-table th:nth-child(1) {
        /* text-align: left; */
        padding-left: 0.75rem;
      }

      .equipment-table th:nth-child(6),  /* Base Rate header */
      .equipment-table th:nth-child(9),  /* Effective Rate header */
      .equipment-table th:nth-child(11)  /* Total header */ {
        text-align: right;
        padding-right: 0.75rem;
      }

      .equipment-table .model-cell {
        font-weight: 600;
        color: var(--primary-blue);
      }

      .equipment-table .action-cell {
        text-align: center;
      }

      .equipment-table .qty-input {
        width: 60px;
        padding: 0.25rem;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        font-size: 0.7rem;
        text-align: center;
      }

      .qty-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: center;
      }

      .btn-delete {
        padding: 0;
        font-size: 1rem;
        background-color: white;
        color: #333;
        border: 1px solid #333;
        border-radius: 0.25rem;
        cursor: pointer;
        transition: background-color 0.2s;
        white-space: nowrap;
        width: 1.5rem;
        height: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        flex-shrink: 0;
      }

      .btn-delete:hover {
        background-color: #e9ecef;
      }

      .btn-delete svg {
        width: 1rem;
        height: 1rem;
        fill: #333;
      }

      .hours-input {
        width: 60px;
        padding: 0.25rem;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        font-size: 0.7rem;
        text-align: center;
      }

      /* Toggle switch styles */
      .rate-type-toggle {
        display: inline-flex;
        border: 1px solid #dee2e6;
        border-radius: 0.25rem;
        overflow: hidden;
        background-color: white;
      }

      .rate-type-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.65rem;
        background-color: white;
        color: #6c757d;
        border: none;
        border-right: 1px solid #dee2e6;
        cursor: pointer;
        transition: all 0.2s;
        font-weight: 500;
      }

      .rate-type-btn:last-child {
        border-right: none;
      }

      .rate-type-btn:hover {
        background-color: #f8f9fa;
      }

      .rate-type-btn.active {
        background-color: var(--primary-blue);
        color: white;
        font-weight: 600;
      }

      .btn-remove {
        padding: 0.25rem 0.5rem;
        font-size: 0.65rem; /* Reduced font size */
        background-color: #dc3545;
        color: white;
        border: none;
        border-radius: 0.25rem;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .btn-remove:hover {
        background-color: #bb2d3b;
      }

      .empty-state {
        text-align: center;
        padding: 3rem 2rem;
        color: #6c757d;
      }

      .empty-state-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
        opacity: 0.5;
      }

      .empty-state-text {
        font-size: 1rem;
        line-height: 1.6;
      }

      .table-actions {
        margin-top: 1rem;
        display: flex;
        gap: 0.5rem;
        justify-content: flex-end;
      }

      .grand-total {
        margin-top: 0.75rem;
        text-align: right;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--primary-blue);
        display: none;
      }

      .btn-action {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        border-radius: 0.25rem;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
        font-weight: 500;
      }

      .btn-clear {
        background-color: #6c757d;
        color: white;
      }

      .btn-clear:hover {
        background-color: #5a6268;
      }

      .btn-export {
        background-color: var(--primary-green);
        color: white;
      }

      .btn-export:hover {
        background-color: #7ab330;
      }
    </style>
  </head>
  <body>
    <!-- Navigation bar container -->
    <nav id="navbar"></nav>

    <main class="container-fluid">
      <div class="left-section">
        <div class="search-container">
          <div class="search-input-wrapper">
            <input
              type="text"
              id="modelSearch"
              class="search-box"
              placeholder="Search for equipment models..."
            />
            <div id="searchResults" class="search-results"></div>
          </div>
        </div>
        <div id="sunburst"></div>
      </div>
      <div class="right-section">
        <div class="equipment-table-container">
          <table class="equipment-table table" id="equipmentTable">
            <colgroup>
              <col class="col-qty" />
              <col class="col-class" />
              <col class="col-make" />
              <col class="col-code" />
              <col class="col-model" />
              <col class="col-base-rate" />
              <col class="col-rate-type" />
              <col class="col-factor" />
              <col class="col-effective-rate" />
              <col class="col-hours" />
              <col class="col-total" />
            </colgroup>
            <thead>
              <tr>
                <th>QTY</th>
                <th>Class</th>
                <th>Make</th>
                <th>Code</th>
                <th>Model</th>
                <th>Base Rate</th>
                <th>Rate Type</th>
                <th>Factor</th>
                <th>Effective Rate</th>
                <th>Hours</th>
                <th>Total</th>
              </tr>
            </thead>
            <tbody id="equipmentTableBody">
              <tr>
                <td colspan="11">
                  <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“‹</div>
                    <div class="empty-state-text">
                      <p><strong>No equipment selected yet</strong></p>
                      <p>
                        Double-click on equipment models in the chart to add
                        them to your list
                      </p>
                    </div>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <div id="grandTotalDisplay" class="grand-total">Grand Total: $0.00</div>
        <div class="table-actions">
          <button
            class="btn-action btn-clear"
            id="clearListBtn"
            style="display: none"
          >
            Clear List
          </button>
          <button
            class="btn-action btn-export"
            id="exportListBtn"
            style="display: none"
          >
            Export List
          </button>
        </div>
      </div>
    </main>

    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Include the navbar JavaScript -->
    <script src="/tools/navbar.js"></script>
    <script>
      // Load navbar
      document.addEventListener("DOMContentLoaded", () =>
        loadNavbar("Cost Estimator")
      );

      // Equipment list management
      const equipmentList = [];
      const equipmentTableBody = document.getElementById("equipmentTableBody");
      const clearListBtn = document.getElementById("clearListBtn");
      const exportListBtn = document.getElementById("exportListBtn");
      const grandTotalDisplay = document.getElementById("grandTotalDisplay");
      const modelSearch = document.getElementById("modelSearch");
      const searchResults = document.getElementById("searchResults");

      // Store all model data for searching
      let allModels = [];
      let makeDescMap = new Map(); // Store make descriptions for search

      // Helper function to format currency for display
      function formatCurrencyDisplay(value) {
        if (value === "N/A" || value === null || value === undefined) {
          return "N/A";
        }
        const numValue = parseFloat(value);
        if (isNaN(numValue)) {
          return "N/A";
        }
        return `$${numValue.toFixed(2)}`;
      }

      // Helper function to format currency for calculations
      function formatCurrency(value) {
        if (value === "N/A" || value === null || value === undefined) {
          return 0;
        }
        const numValue = parseFloat(value);
        return isNaN(numValue) ? 0 : numValue;
      }

      // Add equipment to list function
      function addEquipmentToList(equipment) {
        // Check if equipment already exists in list
        const existingIndex = equipmentList.findIndex(
          (item) =>
            item.class === equipment.class &&
            item.make === equipment.make &&
            item.model === equipment.model
        );

        if (existingIndex !== -1) {
          // If exists, increment quantity
          equipmentList[existingIndex].qty += 1;
        } else {
          // Add new equipment with default values
          equipmentList.push({
            ...equipment,
            qty: 1,
            hours: 1,
            rate_type: equipment.rate_type || "N",
          });
        }

        renderEquipmentTable();
      }

      // Get rate factor based on rate type and equipment data
      function getRateFactor(rateType, rwDelay, overtime) {
        switch (rateType) {
          case "D":
            // Delay - use the equipment's Rw_Delay value
            const delayValue = parseFloat(rwDelay);
            return isNaN(delayValue) ? 1.0 : delayValue;
          case "N":
            return 1.0; // Normal
          case "O":
            // Overtime - use the equipment's Overtime value
            const overtimeValue = parseFloat(overtime);
            return isNaN(overtimeValue) ? 1.0 : overtimeValue + 1;
          default:
            return 1.0;
        }
      }

      // Render equipment table function
      function renderEquipmentTable() {
        if (equipmentList.length === 0) {
          equipmentTableBody.innerHTML = `
            <tr>
              <td colspan="11">
                <div class="empty-state">
                  <div class="empty-state-icon">ðŸ“‹</div>
                  <div class="empty-state-text">
                    <p><strong>No equipment selected yet</strong></p>
                    <p>
                      Double-click on equipment models in the chart to add
                      them to your list
                    </p>
                  </div>
                </div>
              </td>
            </tr>
          `;
          clearListBtn.style.display = "none";
          exportListBtn.style.display = "none";
          grandTotalDisplay.style.display = "none";
          return;
        }

        // Show action buttons
        clearListBtn.style.display = "inline-block";
        exportListBtn.style.display = "inline-block";
        grandTotalDisplay.style.display = "block";

        let grandTotal = 0;
        let html = "";

        equipmentList.forEach((item, index) => {
          const baseRate = formatCurrency(item.rental_rate);
          const factor = getRateFactor(
            item.rate_type,
            item.rw_delay,
            item.overtime
          );
          const effectiveRate = baseRate * factor;
          const hours = parseFloat(item.hours) || 0;
          const total = effectiveRate * hours * item.qty;
          grandTotal += total;

          html += `
            <tr>
              <td>
                <div class="qty-controls">
                  <input type="number" min="1" value="${item.qty}" 
                         class="qty-input" data-index="${index}" />
                </div>
              </td>
              <td>${item.class}</td>
              <td>${item.make}</td>
              <td>${item.model}</td>
              <td class="model-cell">${item.model_desc || ""}</td>
              <td>${formatCurrencyDisplay(item.rental_rate)}</td>
              <td>
                <div class="rate-type-toggle">
                  <button class="rate-type-btn ${
                    item.rate_type === "D" ? "active" : ""
                  }" data-index="${index}" data-type="D">D</button>
                  <button class="rate-type-btn ${
                    item.rate_type === "N" ? "active" : ""
                  }" data-index="${index}" data-type="N">N</button>
                  <button class="rate-type-btn ${
                    item.rate_type === "O" ? "active" : ""
                  }" data-index="${index}" data-type="O">O</button>
                </div>
              </td>
              <td>${factor.toFixed(2)}</td>
              <td>${formatCurrencyDisplay(effectiveRate)}</td>
              <td>
                <input type="number" min="0" step="0.1" value="${hours}" 
                       class="hours-input" data-index="${index}" />
              </td>
              <td>${formatCurrencyDisplay(total)}</td>
            </tr>
          `;
        });

        equipmentTableBody.innerHTML = html;
        grandTotalDisplay.textContent = `Grand Total: ${formatCurrencyDisplay(
          grandTotal
        )}`;

        // Add event listeners
        attachTableEventListeners();
      }

      // Attach event listeners to table controls
      function attachTableEventListeners() {
        // Quantity inputs
        document.querySelectorAll(".qty-input").forEach((input) => {
          input.addEventListener("change", function () {
            const index = parseInt(this.dataset.index);
            const newQty = parseInt(this.value) || 1;
            if (newQty < 1) {
              this.value = 1;
              equipmentList[index].qty = 1;
            } else {
              equipmentList[index].qty = newQty;
            }
            renderEquipmentTable();
          });
        });

        // Hours inputs
        document.querySelectorAll(".hours-input").forEach((input) => {
          input.addEventListener("change", function () {
            const index = parseInt(this.dataset.index);
            const newHours = parseFloat(this.value) || 0;
            equipmentList[index].hours = Math.max(0, newHours);
            renderEquipmentTable();
          });
        });

        // Rate type buttons
        document.querySelectorAll(".rate-type-btn").forEach((btn) => {
          btn.addEventListener("click", function () {
            const index = parseInt(this.dataset.index);
            const rateType = this.dataset.type;
            equipmentList[index].rate_type = rateType;
            renderEquipmentTable();
          });
        });
      }

      // Clear list handler
      clearListBtn.addEventListener("click", () => {
        if (
          confirm("Are you sure you want to clear the entire equipment list?")
        ) {
          equipmentList.length = 0;
          renderEquipmentTable();
        }
      });

      // Export list handler
      exportListBtn.addEventListener("click", () => {
        if (equipmentList.length === 0) {
          alert("No equipment to export!");
          return;
        }

        // Create CSV content
        let csv =
          "QTY,Class,Make,Code,Model,Base Rate,Rate Type,Factor,Effective Rate,Hours,Total\n";

        let grandTotal = 0;
        equipmentList.forEach((item) => {
          const baseRate = formatCurrency(item.rental_rate);
          const factor = getRateFactor(
            item.rate_type,
            item.rw_delay,
            item.overtime
          );
          const effectiveRate = baseRate * factor;
          const hours = parseFloat(item.hours) || 0;
          const total = effectiveRate * hours * item.qty;
          grandTotal += total;

          csv += `${item.qty},${item.class},${item.make},${item.model},"${
            item.model_desc
          }",${baseRate},${item.rate_type},${factor},${effectiveRate.toFixed(
            2
          )},${hours},${total.toFixed(2)}\n`;
        });

        csv += `\nGrand Total:,,,,,,,,,,${grandTotal.toFixed(2)}`;

        // Download CSV
        const blob = new Blob([csv], { type: "text/csv" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `equipment_estimate_${
          new Date().toISOString().split("T")[0]
        }.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      });

      // Load data and create sunburst chart
      async function loadSunburstChart() {
        try {
          const [costResponse, photosResponse] = await Promise.all([
            fetch("cost_data/stnd_2025_04_01_to_2026_03_31.json"),
            fetch("../equipment_photos/equipment_photos.json"),
          ]);

          const data = await costResponse.json();
          const photosData = await photosResponse.json();

          // Build make descriptions map first
          data.forEach((item) => {
            if (item.Class && item.Make && item.Make_Desc) {
              const makeKey = `${item.Class}|${item.Make}`;
              if (!makeDescMap.has(makeKey)) {
                makeDescMap.set(makeKey, item.Make_Desc);
              }
            }
          });

          // Store all models for search functionality with make descriptions
          allModels = data.map((item) => {
            const makeKey = `${item.Class}|${item.Make}`;
            return {
              class: item.Class,
              make: item.Make,
              make_desc: makeDescMap.get(makeKey) || "",
              model: item.Model,
              model_desc: item.Model_Desc || "",
              rental_rate: item.Rental_Rate || "N/A",
              expire_date: item.Expire_Date || "N/A",
              rw_delay: item.Rw_Delay || "N/A",
              overtime: item.Overtime || "N/A",
            };
          });

          // Create a map for equipment photos lookup
          const photoMap = new Map();
          const makePhotoMap = new Map(); // Map for Make-level photos
          const classPhotoMap = new Map(); // NEW: Map for Class-level photos
          photosData.classes.forEach((classItem) => {
            classItem.makes.forEach((makeItem) => {
              makeItem.models.forEach((model) => {
                // Check if model has * or ** marker
                const hasDoubleMarker = model.endsWith("**");
                const hasSingleMarker = model.endsWith("*") && !hasDoubleMarker;
                const cleanModel = model.replace(/\*+$/, ""); // Remove trailing asterisks

                const key = `${classItem.class}|${makeItem.make}|${cleanModel}`;
                const makeKey = `${classItem.class}|${makeItem.make}`;
                const classKey = classItem.class;

                photoMap.set(
                  key,
                  `${classItem.class}_${makeItem.make}_${cleanModel}.jpg`
                );

                // If model has single *, add to Make photo map
                if (hasSingleMarker || hasDoubleMarker) {
                  makePhotoMap.set(
                    makeKey,
                    `${classItem.class}_${makeItem.make}_${cleanModel}.jpg`
                  );
                }

                // If model has **, also add to Class photo map
                if (hasDoubleMarker) {
                  classPhotoMap.set(
                    classKey,
                    `${classItem.class}_${makeItem.make}_${cleanModel}.jpg`
                  );
                }
              });
            });
          });

          // Group data by Class, then Make, then Model
          const classGroups = d3.group(data, (d) => d.Class);

          // Create hierarchy data structure with three levels
          const hierarchyData = {
            name: "root",
            children: Array.from(classGroups, ([className, classItems]) => {
              const makeGroups = d3.group(classItems, (d) => d.Make);

              return {
                name: className,
                children: Array.from(makeGroups, ([makeName, makeItems]) => {
                  const modelGroups = d3.group(makeItems, (d) => d.Model);

                  return {
                    name: makeName,
                    children: Array.from(
                      modelGroups,
                      ([modelName, modelItems]) => ({
                        name: modelName,
                        value: 1, // Each model has equal weight
                      })
                    ),
                  };
                }),
              };
            }),
          };

          // After loading the data, create maps for class, make, and model descriptions
          const classDescMap = new Map();
          const modelDataMap = new Map();

          data.forEach((item) => {
            if (
              item.Class &&
              item.Class_Desc &&
              !classDescMap.has(item.Class)
            ) {
              classDescMap.set(item.Class, item.Class_Desc);
            }

            // Store complete model data with unique key
            if (item.Class && item.Make && item.Model) {
              const modelKey = `${item.Class}|${item.Make}|${item.Model}`;
              if (!modelDataMap.has(modelKey)) {
                modelDataMap.set(modelKey, {
                  model_desc: item.Model_Desc || "No description available",
                  expire_date: item.Expire_Date || "N/A",
                  rental_rate: item.Rental_Rate || "N/A",
                  rw_delay: item.Rw_Delay || "N/A",
                  overtime: item.Overtime || "N/A",
                });
              }
            }
          });

          // Set up dimensions
          const container = document.getElementById("sunburst");
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;

          // Account for padding in the available space
          const paddingLeft =
            parseFloat(getComputedStyle(container).paddingLeft) || 0;
          const paddingRight =
            parseFloat(getComputedStyle(container).paddingRight) || 0;
          const paddingTop =
            parseFloat(getComputedStyle(container).paddingTop) || 0;
          const paddingBottom =
            parseFloat(getComputedStyle(container).paddingBottom) || 0;

          const availableWidth = containerWidth - paddingLeft - paddingRight;
          const availableHeight = containerHeight - paddingTop - paddingBottom;

          const width = availableWidth;
          const height = availableHeight;
          const radius = Math.min(width, height) / 2;

          // Create SVG
          const svg = d3
            .select("#sunburst")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("display", "block")
            .style("margin", "auto")
            .append("g")
            .attr(
              "transform",
              `translate(${width / 2},${height / 2}) rotate(0)`
            );

          const TWO_PI = 2 * Math.PI;
          const normalizeAngle = (angle) => {
            const normalized = angle % TWO_PI;
            return normalized < 0 ? normalized + TWO_PI : normalized;
          };
          const shortestAngularDelta = (start, end) => {
            let delta = end - start;
            if (delta > Math.PI) {
              delta -= TWO_PI;
            } else if (delta < -Math.PI) {
              delta += TWO_PI;
            }
            return delta;
          };

          // Create partition layout
          const partition = d3.partition().size([2 * Math.PI, radius]);

          // Create hierarchy
          const root = d3.hierarchy(hierarchyData).sum((d) => d.value);

          partition(root);

          // IMPORTANT: Manually set equal angular size for all Class segments
          const totalClasses = hierarchyData.children.length;
          const classSize = (2 * Math.PI) / totalClasses;

          root.children.forEach((classNode, index) => {
            const classStart = index * classSize;
            const classEnd = (index + 1) * classSize;

            // Set Class angles
            classNode.x0 = classStart;
            classNode.x1 = classEnd;

            // Calculate total number of models in this Class
            const totalModelsInClass = classNode.children.reduce(
              (sum, makeNode) =>
                sum + (makeNode.children ? makeNode.children.length : 0),
              0
            );

            // Distribute Makes proportionally based on number of models
            if (classNode.children && totalModelsInClass > 0) {
              let currentAngle = classStart;

              classNode.children.forEach((makeNode, makeIndex) => {
                const numModels = makeNode.children
                  ? makeNode.children.length
                  : 0;
                const makeProportion = numModels / totalModelsInClass;
                const makeAngularSize =
                  (classEnd - classStart) * makeProportion;

                const makeStart = currentAngle;
                const makeEnd = currentAngle + makeAngularSize;

                makeNode.x0 = makeStart;
                makeNode.x1 = makeEnd;

                // Distribute Models evenly within this Make segment
                if (makeNode.children) {
                  const modelSize = makeAngularSize / makeNode.children.length;
                  makeNode.children.forEach((modelNode, modelIndex) => {
                    const modelStart = makeStart + modelIndex * modelSize;
                    const modelEnd = modelStart + modelSize;
                    modelNode.x0 = modelStart;
                    modelNode.x1 = modelEnd;
                  });
                }

                currentAngle = makeEnd;
              });
            }
          });

          // Create custom color scale with more pleasing, harmonious colors
          const baseColors = [
            "#017dc3", // primary blue
            "#4a9acc", // lighter blue
            "#8bbbd8", // faded blue
            "#5a9fc7", // medium blue
            "#0165a0", // darker blue
            "#7ab330", // primary green (adjusted)
            "#a3d96a", // medium green
            "#b8dc8f", // faded green
            "#8fc83b", // lighter green
            "#6b9e2d", // darker green
            "#e5a410", // darker yellow/gold
            "#f4c145", // medium yellow/gold
            "#fcd788", // light yellow/gold
            "#d89b0d", // bronze
            "#c78a2e", // warm gold
          ];

          const color = d3.scaleOrdinal(baseColors);

          // Create arc generator with adjusted inner/outer radius for three levels
          const arc = d3
            .arc()
            .startAngle((d) => d.x0)
            .endAngle((d) => d.x1)
            .innerRadius((d) => {
              // Adjusted ring widths to use full radius
              if (d.depth === 1) return radius * 0.33; // Class inner radius
              if (d.depth === 2) return radius * 0.6; // Make inner radius
              if (d.depth === 3) return radius * 0.8; // Model inner radius
              return d.y0;
            })
            .outerRadius((d) => {
              // Adjusted ring widths to use full radius
              if (d.depth === 1) return radius * 0.6; // Class outer radius
              if (d.depth === 2) return radius * 0.8; // Make outer radius
              if (d.depth === 3) return radius * 1.0; // Model outer radius - full radius
              return d.y1;
            });

          // Track current state
          let selectedSegment = null; // Track the selected segment
          let selectedMake = null; // Track the selected Make segment
          let isExpanded = false; // Track if a segment is expanded
          const OPACITY_FADE_DURATION = 300;
          const ARC_ANIMATION_DURATION = 500;
          const MAKE_TARGET_SIZE = (240 * Math.PI) / 180; // 240 degrees for Make expansion

          function applyAnglesToMake(makeNode, startAngle, endAngle) {
            makeNode.x0 = startAngle;
            makeNode.x1 = endAngle;

            if (makeNode.children && makeNode.children.length > 0) {
              const modelCount = makeNode.children.length;
              const modelSpan = (endAngle - startAngle) / modelCount;
              let currentModelAngle = startAngle;

              makeNode.children.forEach((modelNode) => {
                modelNode.x0 = currentModelAngle;
                modelNode.x1 = currentModelAngle + modelSpan;
                currentModelAngle += modelSpan;
              });
            }
          }

          function makeWeight(makeNode) {
            if (!makeNode.children || makeNode.children.length === 0) {
              return 1;
            }
            return makeNode.children.length;
          }

          function isDescendantOf(node, ancestor) {
            if (!node || !ancestor) return false;
            let current = node;
            while (current && current !== ancestor) {
              current = current.parent;
            }
            return current === ancestor;
          }

          function animateSunburstLayout() {
            svg
              .selectAll("path")
              .transition()
              .duration(ARC_ANIMATION_DURATION)
              .attrTween("d", function (d) {
                const startX0 =
                  this._currentX0 !== undefined ? this._currentX0 : d.x0;
                const startX1 =
                  this._currentX1 !== undefined ? this._currentX1 : d.x1;

                const preserveDirectionalMotion =
                  selectedSegment &&
                  d.depth > 1 &&
                  isDescendantOf(d, selectedSegment);

                const deltaX0 = preserveDirectionalMotion
                  ? d.x0 - startX0
                  : shortestAngularDelta(startX0, d.x0);
                const deltaX1 = preserveDirectionalMotion
                  ? d.x1 - startX1
                  : shortestAngularDelta(startX1, d.x1);

                return function (t) {
                  const tempD = { ...d };
                  const interpolatedX0 = startX0 + deltaX0 * t;
                  const interpolatedX1 = startX1 + deltaX1 * t;

                  tempD.x0 = normalizeAngle(interpolatedX0);
                  tempD.x1 = normalizeAngle(interpolatedX1);

                  if (tempD.x1 <= tempD.x0) {
                    tempD.x1 += TWO_PI;
                  }

                  return arc(tempD);
                };
              })
              .on("end", function (d) {
                this._currentX0 = d.x0;
                this._currentX1 = d.x1;
              });

            classLabels
              .transition()
              .duration(ARC_ANIMATION_DURATION)
              .attr("transform", function (d) {
                const [x, y] = arc.centroid(d);
                let angle = (((d.x0 + d.x1) / 2) * 180) / Math.PI - 90;
                if (angle < -90 || angle > 90) {
                  angle += 180;
                }
                return `translate(${x},${y}) rotate(${angle})`;
              });

            makeLabels
              .transition()
              .duration(ARC_ANIMATION_DURATION)
              .attr("transform", function (d) {
                const [x, y] = arc.centroid(d);
                let angle = (((d.x0 + d.x1) / 2) * 180) / Math.PI - 90;
                if (angle < -90 || angle > 90) {
                  angle += 180;
                }
                return `translate(${x},${y}) rotate(${angle})`;
              });

            if (!activeModelLabels.empty()) {
              activeModelLabels
                .transition()
                .duration(ARC_ANIMATION_DURATION)
                .attr("transform", computeModelLabelTransform);
            }
          }

          function updateMakeSegmentSizes(classNode, focusMake = null) {
            if (
              !classNode ||
              !classNode.children ||
              classNode.children.length === 0
            ) {
              return;
            }

            const classStart = classNode.x0;
            const classEnd = classNode.x1;
            const classSpan = classEnd - classStart;
            const orderedMakes = classNode.children.slice();

            if (!focusMake) {
              const totalWeight = orderedMakes.reduce(
                (sum, makeNode) => sum + makeWeight(makeNode),
                0
              );

              let currentAngle = classStart;
              orderedMakes.forEach((makeNode) => {
                const weight = makeWeight(makeNode);
                const proportion =
                  totalWeight > 0
                    ? weight / totalWeight
                    : 1 / orderedMakes.length;
                const makeSpan = classSpan * proportion;
                applyAnglesToMake(
                  makeNode,
                  currentAngle,
                  currentAngle + makeSpan
                );
                currentAngle += makeSpan;
              });

              animateSunburstLayout();
              return;
            }

            const hasOtherMakes = orderedMakes.length > 1;
            const targetSpan = hasOtherMakes
              ? Math.min(MAKE_TARGET_SIZE, classSpan)
              : classSpan;
            const otherMakes = orderedMakes.filter(
              (node) => node !== focusMake
            );
            const remainingSpan = hasOtherMakes
              ? Math.max(classSpan - targetSpan, 0)
              : 0;
            const otherWeight = otherMakes.reduce(
              (sum, node) => sum + makeWeight(node),
              0
            );

            let currentAngle = classStart;
            orderedMakes.forEach((makeNode) => {
              let span;
              if (makeNode === focusMake) {
                span = hasOtherMakes ? targetSpan : classSpan;
              } else if (remainingSpan === 0) {
                span = 0;
              } else if (otherWeight > 0) {
                span = remainingSpan * (makeWeight(makeNode) / otherWeight);
              } else {
                span = remainingSpan / otherMakes.length;
              }

              applyAnglesToMake(makeNode, currentAngle, currentAngle + span);
              currentAngle += span;
            });

            animateSunburstLayout();
          }

          // Function to expand/shrink segments
          function updateSegmentSizes(selectedData, expand = true) {
            if (expand) {
              const targetSize = (270 * Math.PI) / 180;
              const remainingSize = 2 * Math.PI - targetSize;

              // Create a mapping of Class segment names to their original indices
              const segmentOrder = {};
              hierarchyData.children.forEach((child, index) => {
                segmentOrder[child.name] = index;
              });

              // Find the root Class for the selected segment
              let classSegment = selectedData;
              while (classSegment.depth > 1) {
                classSegment = classSegment.parent;
              }

              const selectedIndex = segmentOrder[classSegment.data.name];
              const totalSegments = hierarchyData.children.length;

              const segmentSize = (2 * Math.PI) / totalSegments;
              const originalStartAngle = selectedIndex * segmentSize;
              const originalEndAngle = (selectedIndex + 1) * segmentSize;
              const originalMidpoint =
                (originalStartAngle + originalEndAngle) / 2;

              const expandedStartAngle = originalMidpoint - targetSize / 2;
              const expandedEndAngle = originalMidpoint + targetSize / 2;

              let oppositeMidpoint = originalMidpoint + Math.PI;
              if (oppositeMidpoint >= 2 * Math.PI) {
                oppositeMidpoint -= 2 * Math.PI;
              }

              let remainingStartAngle = oppositeMidpoint - remainingSize / 2;
              if (remainingStartAngle < 0) {
                remainingStartAngle += 2 * Math.PI;
              }

              const otherSegments = [];
              for (let i = 1; i < totalSegments; i++) {
                const currentIndex = (selectedIndex + i) % totalSegments;
                const segment = root
                  .descendants()
                  .find(
                    (d) =>
                      d.depth === 1 &&
                      segmentOrder[d.data.name] === currentIndex
                  );
                if (segment) {
                  otherSegments.push(segment);
                }
              }

              const otherSegmentSize = remainingSize / otherSegments.length;

              // Update angles for the selected Class and all its children
              function updateAnglesRecursive(node, startAngle, endAngle) {
                node.x0 = startAngle;
                node.x1 = endAngle;

                if (node.children) {
                  // Calculate total models for proportional distribution
                  const totalModels = node.children.reduce(
                    (sum, child) =>
                      sum + (child.children ? child.children.length : 0),
                    0
                  );

                  let currentAngle = startAngle;

                  node.children.forEach((child, i) => {
                    const numModels = child.children
                      ? child.children.length
                      : 0;
                    const childProportion =
                      totalModels > 0
                        ? numModels / totalModels
                        : 1 / node.children.length;
                    const childAngularSize =
                      (endAngle - startAngle) * childProportion;

                    const childStart = currentAngle;
                    const childEnd = currentAngle + childAngularSize;

                    updateAnglesRecursive(child, childStart, childEnd);
                    currentAngle = childEnd;
                  });
                }
              }

              updateAnglesRecursive(
                classSegment,
                expandedStartAngle,
                expandedEndAngle
              );

              // Place other Class segments and their children
              let currentAngle = remainingStartAngle;
              otherSegments.forEach((d) => {
                updateAnglesRecursive(
                  d,
                  currentAngle,
                  currentAngle + otherSegmentSize
                );
                currentAngle += otherSegmentSize;

                if (currentAngle >= 2 * Math.PI) {
                  currentAngle -= 2 * Math.PI;
                }
              });
            } else {
              // Reset to equal sizes
              const totalClasses = hierarchyData.children.length;
              const classSize = (2 * Math.PI) / totalClasses;

              const segmentOrder = {};
              hierarchyData.children.forEach((child, index) => {
                segmentOrder[child.name] = index;
              });

              function resetAnglesRecursive(node) {
                if (node.depth === 0) {
                  // Root node - reset all Class children
                  node.children.forEach((classNode) => {
                    const classIndex = segmentOrder[classNode.data.name];
                    const classStart = classIndex * classSize;
                    const classEnd = (classIndex + 1) * classSize;

                    classNode.x0 = classStart;
                    classNode.x1 = classEnd;

                    // Calculate total models in this class
                    const totalModels = classNode.children.reduce(
                      (sum, makeNode) =>
                        sum +
                        (makeNode.children ? makeNode.children.length : 0),
                      0
                    );

                    let currentAngle = classStart;
                    classNode.children.forEach((makeNode) => {
                      const numModels = makeNode.children
                        ? makeNode.children.length
                        : 0;
                      const makeProportion =
                        totalModels > 0
                          ? numModels / totalModels
                          : 1 / classNode.children.length;
                      const makeAngularSize =
                        (classEnd - classStart) * makeProportion;

                      resetAnglesRecursive(
                        makeNode,
                        currentAngle,
                        currentAngle + makeAngularSize
                      );
                      currentAngle += makeAngularSize;
                    });
                  });
                } else {
                  // Class, Make, or Model node
                  const start = arguments[1];
                  const end = arguments[2];
                  node.x0 = start;
                  node.x1 = end;

                  if (node.children) {
                    const childSize = (end - start) / node.children.length;
                    node.children.forEach((child, i) => {
                      const childStart = start + i * childSize;
                      const childEnd = childStart + childSize;
                      resetAnglesRecursive(child, childStart, childEnd);
                    });
                  }
                }
              }

              resetAnglesRecursive(root);
            }

            // Animate the arc changes
            animateSunburstLayout();
          }

          // Draw arcs - include all depths > 0 (Class, Make, Model)
          const arcs = svg
            .selectAll("path")
            .data(root.descendants().filter((d) => d.depth > 0))
            .join("path")
            .attr("class", "sunburst-arc")
            .attr("d", arc)
            .style("fill", (d) => {
              // Color based on the root Class
              let colorNode = d;
              while (colorNode.depth > 1) {
                colorNode = colorNode.parent;
              }
              return colorNode.data.name === "root"
                ? "transparent"
                : color(colorNode.data.name);
            })
            .style("opacity", (d) => {
              // Initially hide Make (depth 2) and Model (depth 3) rings
              if (d.depth === 1) return 0.85; // Class - visible
              return 0; // Make and Model - hidden initially
            })
            .style("pointer-events", (d) => {
              // Initially disable interactions for Make and Model rings
              return d.depth === 1 ? "auto" : "none";
            })
            .each(function (d) {
              this._currentX0 = d.x0;
              this._currentX1 = d.x1;
            });

          const classLabels = svg
            .selectAll("text.class-label")
            .data(root.descendants().filter((d) => d.depth === 1))
            .join("text")
            .attr("class", "class-label")
            .attr("transform", function (d) {
              const [x, y] = arc.centroid(d);
              let angle = (((d.x0 + d.x1) / 2) * 180) / Math.PI - 90;
              if (angle < -90 || angle > 90) {
                angle += 180;
              }
              return `translate(${x},${y}) rotate(${angle})`;
            })
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("font-size", "0.8rem") /* Reduced to match other rings */
            .attr("font-weight", "bold")
            .attr("fill", "#1a1a1a")
            .attr("pointer-events", "none")
            .text((d) => d.data.name);

          const makeLabels = svg
            .selectAll("text.make-label")
            .data(root.descendants().filter((d) => d.depth === 2))
            .join("text")
            .attr("class", "make-label")
            .attr("transform", function (d) {
              const [x, y] = arc.centroid(d);
              let angle = (((d.x0 + d.x1) / 2) * 180) / Math.PI - 90;
              if (angle < -90 || angle > 90) {
                angle += 180;
              }
              return `translate(${x},${y}) rotate(${angle})`;
            })
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("font-size", "0.8rem") /* Reduced to match other rings */
            .attr("font-weight", "bold")
            .attr("fill", "#1a1a1a")
            .attr("pointer-events", "none")
            .style("opacity", 0)
            .text((d) => d.data.name);

          const modelLabelsGroup = svg
            .append("g")
            .attr("class", "model-label-group");

          let activeModelLabels =
            modelLabelsGroup.selectAll("text.model-label");

          const computeModelLabelTransform = (d) => {
            const [x, y] = arc.centroid(d);
            let angle = (((d.x0 + d.x1) / 2) * 180) / Math.PI - 90;
            if (angle < -90 || angle > 90) {
              angle += 180;
            }
            return `translate(${x},${y}) rotate(${angle})`;
          };

          function hideModelLabels() {
            if (activeModelLabels.empty()) return;

            activeModelLabels
              .transition()
              .duration(OPACITY_FADE_DURATION)
              .style("opacity", 0)
              .remove();

            activeModelLabels = modelLabelsGroup.selectAll("text.model-label");
          }

          function showModelLabelsForMake(makeNode) {
            if (
              !makeNode ||
              !makeNode.children ||
              makeNode.children.length === 0
            ) {
              hideModelLabels();
              return;
            }

            const joined = modelLabelsGroup
              .selectAll("text.model-label")
              .data(makeNode.children, (d) => d.data.name);

            joined
              .exit()
              .transition()
              .duration(OPACITY_FADE_DURATION)
              .style("opacity", 0)
              .remove();

            const entered = joined
              .enter()
              .append("text")
              .attr("class", "model-label")
              .attr("text-anchor", "middle")
              .attr("alignment-baseline", "middle")
              .attr("font-size", "0.8rem") /* Increased to match other rings */
              .attr("font-weight", "600")
              .attr("fill", "#1a1a1a")
              .attr("pointer-events", "none")
              .attr("transform", computeModelLabelTransform)
              .style("opacity", 0)
              .text((d) => d.data.name);

            activeModelLabels = entered
              .merge(joined)
              .attr("transform", computeModelLabelTransform);

            activeModelLabels
              .transition()
              .duration(OPACITY_FADE_DURATION)
              .style("opacity", 1);
          }

          // Create tooltip div
          const tooltip = d3
            .select("body")
            .append("div")
            .attr("class", "tooltip");

          // Function to position tooltip within viewport
          function positionTooltip(event, tooltipNode) {
            const tooltipWidth = tooltipNode.offsetWidth;
            const tooltipHeight = tooltipNode.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const scrollX = window.pageXOffset;
            const scrollY = window.pageYOffset;

            let left = event.pageX + 15;
            let top = event.pageY - 15;

            // Check if tooltip would overflow right edge
            if (left + tooltipWidth > scrollX + viewportWidth) {
              left = event.pageX - tooltipWidth - 15;
            }

            // Check if tooltip would overflow bottom edge
            if (top + tooltipHeight > scrollY + viewportHeight) {
              top = event.pageY - tooltipHeight + 15;
            }

            // Ensure tooltip doesn't go off left edge
            if (left < scrollX) {
              left = scrollX + 10;
            }

            // Ensure tooltip doesn't go off top edge
            if (top < scrollY) {
              top = scrollY + 10;
            }

            return { left, top };
          }

          // Add hover handlers for tooltips
          arcs
            .on("mouseenter", function (event, d) {
              if (d.depth === 1) {
                // Class level - show styled tooltip
                const className = d.data.name;
                const classDesc =
                  classDescMap.get(className) || "No description available";
                const makeCount = d.children ? d.children.length : 0;
                const modelCount = d.children
                  ? d.children.reduce(
                      (sum, make) =>
                        sum + (make.children ? make.children.length : 0),
                      0
                    )
                  : 0;

                // Get representative photo for Class if available
                const classPhotoFilename = classPhotoMap.get(className);
                const classPhotoHTML = classPhotoFilename
                  ? `<div style="text-align: center; margin-top: 8px;">
                             <img src="../equipment_photos/${classPhotoFilename}"
                                  alt="${className}"
                                  style="max-width: 100%; max-height: 250px; border-radius: 4px; border: 1px solid #dee2e6;"
                                  onerror="this.style.display='none'">
                           </div>`
                  : "";

                tooltip
                  .attr(
                    "class",
                    classPhotoFilename ? "tooltip has-photo" : "tooltip"
                  )
                  .html(
                    `
                <div class="tooltip-title">${className}</div>
                <div class="tooltip-description">${classDesc}</div>
                ${classPhotoHTML}
                <div class="tooltip-stats">
                  <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Makes:</span>
                    <span class="tooltip-stat-value">${makeCount}</span>
                  </div>
                  <div class="tooltip-stat">
                    <span class="tooltip-stat-label">Models:</span>
                    <span class="tooltip-stat-value">${modelCount}</span>
                  </div>
                </div>
              `
                  )
                  .style("opacity", 1);

                const pos = positionTooltip(event, tooltip.node());
                tooltip
                  .style("left", pos.left + "px")
                  .style("top", pos.top + "px");
              } else if (d.depth === 2) {
                // Make level - only show tooltip if this Make is active
                // Check if a Make is selected and this is not it
                if (selectedMake && d !== selectedMake) {
                  return; // Don't show tooltip for inactive Makes
                }

                // Check if no Make is selected but a Class is selected
                // In this case, check if this Make belongs to the selected Class
                if (selectedSegment && !selectedMake) {
                  let classNode = d;
                  while (classNode.depth > 1) {
                    classNode = classNode.parent;
                  }
                  if (classNode !== selectedSegment) {
                    return; // Don't show tooltip for Makes outside selected Class
                  }
                }

                // Make level - show styled tooltip with model count
                const makeName = d.data.name;
                const className = d.parent.data.name;
                const makeKey = `${className}|${makeName}`;
                const makeDesc =
                  makeDescMap.get(makeKey) || "No description available";
                const modelCount = d.children ? d.children.length : 0;

                // Get representative photo for Make if available
                const makePhotoFilename = makePhotoMap.get(makeKey);
                const makePhotoHTML = makePhotoFilename
                  ? `<div style="text-align: center; margin-top: 8px;">
                             <img src="../equipment_photos/${makePhotoFilename}"
                                  alt="${makeName}"
                                  style="max-width: 100%; max-height: 250px; border-radius: 4px; border: 1px solid #dee2e6;"
                                  onerror="this.style.display='none'">
                           </div>`
                  : "";

                tooltip
                  .attr(
                    "class",
                    makePhotoFilename ? "tooltip has-photo" : "tooltip"
                  )
                  .html(
                    `
            <div class="tooltip-title">${makeName}</div>
            <div class="tooltip-description">${makeDesc}</div>
            ${makePhotoHTML}
            <div class="tooltip-stats">
              <div class="tooltip-stat">
                <span class="tooltip-stat-label">${className} Models:</span>
                <span class="tooltip-stat-value">${modelCount}</span>
              </div>
            </div>
          `
                  )
                  .style("opacity", 1);

                const pos = positionTooltip(event, tooltip.node());
                tooltip
                  .style("left", pos.left + "px")
                  .style("top", pos.top + "px");
              } else {
                // Model level - show styled tooltip with complete model info
                const modelName = d.data.name;
                const makeName = d.parent.data.name;
                const className = d.parent.parent.data.name;
                const modelKey = `${className}|${makeName}|${modelName}`;
                const makeKey = `${className}|${makeName}`;

                const modelData = modelDataMap.get(modelKey) || {
                  model_desc: "No description available",
                  expire_date: "N/A",
                  rental_rate: "N/A",
                  rw_delay: "N/A",
                  overtime: "N/A",
                };

                const classDesc =
                  classDescMap.get(className) || "No description available";
                const makeDesc =
                  makeDescMap.get(makeKey) || "No description available";

                // Get equipment photo if available
                const photoFilename = photoMap.get(modelKey);
                const photoHTML = photoFilename
                  ? `<div style="text-align: center; margin-top: 8px;">
                             <img src="../equipment_photos/${photoFilename}"
                                  alt="${modelName}"
                                  style="max-width: 100%; max-height: 250px; border-radius: 4px; border: 1px solid #dee2e6;"
                                  onerror="this.style.display='none'">
                           </div>`
                  : "";

                tooltip
                  .attr(
                    "class",
                    photoFilename ? "tooltip has-photo" : "tooltip"
                  )
                  .html(
                    `
      <div class="tooltip-title" style="text-align: center;">${makeName} ${
                      modelData.model_desc
                    }</div>
                          <div class="tooltip-description" style="text-align: center; margin-bottom: 8px;">${modelName}</div>
      ${photoHTML}
      <table class="tooltip-table">
        <tr>
          <td>Expire Date:</td>
          <td>${modelData.expire_date}</td>
        </tr>
        <tr>
          <td>Rental Rate:</td>
          <td>${formatCurrencyDisplay(modelData.rental_rate)}</td>
        </tr>
        <tr>
          <td>Delay:</td>
          <td>${modelData.rw_delay}</td>
        </tr>
        <tr>
          <td>Overtime:</td>
          <td>${modelData.overtime}</td>
        </tr>
      </table>
      <div style="border-top: 1.5px solid var(--primary-yellow); margin-top: 8px; padding-top: 8px;">
        <div class="tooltip-description" style="font-size: 0.65rem; color: #555; margin-bottom: 2px;">Class: ${className}</div>
        <div class="tooltip-description" style="font-style: italic; font-size: 0.65rem; color: #555; margin-bottom: 12px;">${classDesc}</div>
        <div class="tooltip-description" style="font-size: 0.65rem; color: #555; margin-bottom: 2px;">Make: ${makeName}</div>
        <div class="tooltip-description" style="font-style: italic; font-size: 0.65rem; color: #555;">${makeDesc}</div>
      </div>
      `
                  )
                  .style("opacity", 1);

                const pos = positionTooltip(event, tooltip.node());
                tooltip
                  .style("left", pos.left + "px")
                  .style("top", pos.top + "px");
              }

              // Hover opacity changes - darken on hover
              if (!selectedSegment && d.depth === 1) {
                d3.select(this).style("opacity", 1); // Darken from 0.85 to 1
              } else if (selectedSegment && !selectedMake && d.depth === 2) {
                let classNode = d;
                while (classNode.depth > 1) {
                  classNode = classNode.parent;
                }
                if (classNode === selectedSegment) {
                  d3.select(this).style("opacity", 0.9);
                }
              } else if (selectedMake && d.depth === 2 && d === selectedMake) {
                d3.select(this).style("opacity", 0.9);
              } else if (selectedMake && d.depth === 3) {
                // Model hover when Make is selected
                if (d.parent === selectedMake) {
                  d3.select(this).style("opacity", 0.75);
                }
              }
            })
            .on("mousemove", function (event) {
              const pos = positionTooltip(event, tooltip.node());
              tooltip
                .style("left", pos.left + "px")
                .style("top", pos.top + "px");
            })
            .on("mouseleave", function (event, d) {
              tooltip.style("opacity", 0);

              // Restore original opacity on hover leave
              if (!selectedSegment && d.depth === 1) {
                d3.select(this).style("opacity", 0.85); // Restore to 0.85
              } else if (selectedSegment && !selectedMake && d.depth === 2) {
                let classNode = d;
                while (classNode.depth > 1) {
                  classNode = classNode.parent;
                }
                if (classNode === selectedSegment) {
                  d3.select(this).style("opacity", 0.7);
                }
              } else if (selectedMake && d.depth === 2 && d === selectedMake) {
                d3.select(this).style("opacity", 0.85);
              } else if (selectedMake && d.depth === 3) {
                // Model hover leave when Make is selected
                if (d.parent === selectedMake) {
                  d3.select(this).style("opacity", 0.55);
                }
              }
            });

          // Add click handler - handle both Class and Make clicks
          svg.selectAll("path").on("click", (event, d) => {
            event.stopPropagation();

            if (d.depth === 1) {
              hideModelLabels();

              // Handle Class level clicks (depth 1)
              if (selectedSegment === d) {
                // Deselecting Class - reverse animations
                selectedSegment = null;
                selectedMake = null;

                svg
                  .selectAll("path")
                  .transition()
                  .duration(OPACITY_FADE_DURATION)
                  .style("opacity", (segment) => {
                    if (segment.depth === 1) return 0.85; // Show Class
                    return 0; // Hide Make and Model
                  })
                  .style("pointer-events", (segment) => {
                    return segment.depth === 1 ? "auto" : "none";
                  });

                makeLabels
                  .transition()
                  .duration(OPACITY_FADE_DURATION)
                  .style("opacity", 0);

                // Keep the selected Class label visible during deselection
                classLabels
                  .transition()
                  .duration(OPACITY_FADE_DURATION)
                  .style("opacity", (segment) => (segment === d ? 1 : 0));

                setTimeout(() => {
                  updateSegmentSizes(null, false);
                  isExpanded = false;
                }, OPACITY_FADE_DURATION);

                setTimeout(() => {
                  // Show all Class labels after animation completes
                  classLabels
                    .transition()
                    .duration(OPACITY_FADE_DURATION)
                    .style("opacity", 1);
                }, OPACITY_FADE_DURATION + ARC_ANIMATION_DURATION);
              } else {
                // Selecting a new Class
                selectedSegment = d;
                selectedMake = null;

                classLabels
                  .transition()
                  .duration(300)
                  .style("opacity", (segment) => (segment === d ? 1 : 0));

                svg
                  .selectAll("path")
                  .transition()
                  .duration(300)
                  .style("opacity", (segment) => {
                    let classNode = segment;
                    while (classNode.depth > 1) {
                      classNode = classNode.parent;
                    }

                    if (classNode === d) {
                      if (segment.depth === 1) return 0.85; // Class
                      if (segment.depth === 2) return 0.7; // Make - visible
                      return 0; // Model - hidden initially
                    }
                    return segment.depth === 1 ? 0.2 : 0;
                  })
                  .style("pointer-events", (segment) => {
                    let classNode = segment;
                    while (classNode.depth > 1) {
                      classNode = classNode.parent;
                    }
                    if (
                      classNode === d &&
                      (segment.depth === 1 || segment.depth === 2)
                    ) {
                      return "auto";
                    }
                    return "none";
                  });

                setTimeout(() => {
                  updateSegmentSizes(d, true);
                  isExpanded = true;

                  setTimeout(() => {
                    makeLabels
                      .transition()
                      .duration(300)
                      .style("opacity", (segment) => {
                        let classNode = segment;
                        while (classNode.depth > 1) {
                          classNode = classNode.parent;
                        }
                        return classNode === d ? 1 : 0;
                      });
                  }, 500);
                }, 300);
              }
            }

            // Handle Make level clicks (depth 2)
            else if (d.depth === 2) {
              // Ignore clicks on inactive Makes
              if (selectedMake && d !== selectedMake) {
                return; // Don't respond to clicks on faded Makes
              }

              // Ignore clicks on Makes outside the selected Class
              if (selectedSegment) {
                let classNode = d;
                while (classNode.depth > 1) {
                  classNode = classNode.parent;
                }
                if (classNode !== selectedSegment) {
                  return; // Don't respond to clicks on Makes outside selected Class
                }
              }

              if (selectedMake === d) {
                selectedMake = null;
                hideModelLabels();

                svg
                  .selectAll("path")
                  .transition()
                  .duration(OPACITY_FADE_DURATION)
                  .style("fill", (segment) => {
                    // Restore original colors
                    let colorNode = segment;
                    while (colorNode.depth > 1) {
                      colorNode = colorNode.parent;
                    }
                    return colorNode.data.name === "root"
                      ? "transparent"
                      : color(colorNode.data.name);
                  })
                  .style("opacity", (segment) => {
                    let classNode = segment;
                    while (classNode.depth > 1) {
                      classNode = classNode.parent;
                    }

                    if (classNode === selectedSegment) {
                      if (segment.depth === 1) return 0.85; // Class
                      if (segment.depth === 2) return 0.7; // Make
                      return 0; // Model - hide
                    }
                    return segment.depth === 1 ? 0.2 : 0;
                  })
                  .style("pointer-events", (segment) => {
                    let classNode = segment;
                    while (classNode.depth > 1) {
                      classNode = classNode.parent;
                    }
                    if (
                      classNode === selectedSegment &&
                      (segment.depth === 1 || segment.depth === 2)
                    ) {
                      return "auto";
                    }
                    return "none";
                  });

                setTimeout(() => {
                  if (selectedSegment) {
                    updateMakeSegmentSizes(selectedSegment, null);
                  }

                  // Wait for arc animation to complete before showing labels
                  setTimeout(() => {
                    makeLabels
                      .transition()
                      .duration(OPACITY_FADE_DURATION)
                      .style("opacity", (segment) => {
                        let classNode = segment;
                        while (classNode.depth > 1) {
                          classNode = classNode.parent;
                        }
                        return classNode === selectedSegment ? 1 : 0;
                      });
                  }, ARC_ANIMATION_DURATION);
                }, OPACITY_FADE_DURATION);
              } else {
                // Selecting a Make - fade other Makes (depth 2) to grey
                selectedMake = d;
                hideModelLabels();

                svg
                  .selectAll("path")
                  .transition()
                  .duration(OPACITY_FADE_DURATION)
                  .style("fill", (segment) => {
                    let colorNode = segment;
                    while (colorNode.depth > 1) {
                      colorNode = colorNode.parent;
                    }
                    const baseColor = color(colorNode.data.name);

                    // Keep Classes and Models in their original colors
                    return baseColor;
                  })
                  .style("opacity", (segment) => {
                    let classNode = segment;
                    while (classNode.depth > 1) {
                      classNode = classNode.parent;
                    }

                    if (classNode === selectedSegment) {
                      if (segment.depth === 1) return 0.85; // Class
                      if (segment.depth === 2) {
                        return segment === d ? 0.85 : 0.2; // Fade unselected Makes to 0.2
                      }
                      if (segment.depth === 3) {
                        // Show Models only for selected Make
                        return segment.parent === d ? 0.55 : 0;
                      }
                    }
                    return segment.depth === 1 ? 0.2 : 0;
                  })
                  .style("pointer-events", (segment) => {
                    let classNode = segment;
                    while (classNode.depth > 1) {
                      classNode = classNode.parent;
                    }

                    if (classNode === selectedSegment && segment.depth <= 3) {
                      return "auto";
                    }
                    return "none";
                  });

                // Hide labels for unselected Makes
                makeLabels
                  .transition()
                  .duration(OPACITY_FADE_DURATION)
                  .style("opacity", (segment) => {
                    return segment === d ? 1 : 0;
                  });

                setTimeout(() => {
                  if (selectedSegment) {
                    updateMakeSegmentSizes(selectedSegment, selectedMake);
                    setTimeout(() => {
                      if (selectedMake) {
                        showModelLabelsForMake(selectedMake);
                      }
                    }, ARC_ANIMATION_DURATION);
                  }
                }, OPACITY_FADE_DURATION);
              }
            }
          });

          // Add double-click handler for Model segments (depth 3)
          svg.selectAll("path").on("dblclick", (event, d) => {
            event.stopPropagation();

            if (d.depth === 3) {
              // Model level - add to equipment list
              const modelName = d.data.name;
              const makeName = d.parent.data.name;
              const className = d.parent.parent.data.name;
              const modelKey = `${className}|${makeName}|${modelName}`;
              const modelData = modelDataMap.get(modelKey);

              if (modelData) {
                const equipment = {
                  model: modelName,
                  make: makeName,
                  class: className,
                  model_desc: modelData.model_desc || "",
                  rental_rate: modelData.rental_rate || "N/A",
                  rate_type: "N", // Default to Normal
                  expire_date: modelData.expire_date || "N/A",
                  rw_delay: modelData.rw_delay || "N/A",
                  overtime: modelData.overtime || "N/A",
                };

                addEquipmentToList(equipment);

                // Visual feedback - briefly highlight the segment
                d3.select(event.currentTarget)
                  .transition()
                  .duration(200)
                  .style("opacity", 1)
                  .transition()
                  .duration(200)
                  .style("opacity", 0.55);
              }
            }
          });
        } catch (error) {
          console.error("Error loading chart data:", error);
          document.getElementById("sunburst").innerHTML = `

                  <div class="alert alert-danger" role="alert">
                    Error loading equipment data. Please try again later.
                  </div>
                `;
        }
      }

      // Load chart when DOM is ready
      document.addEventListener("DOMContentLoaded", loadSunburstChart);

      // Search functionality
      modelSearch.addEventListener("input", function () {
        const searchTerm = this.value.toLowerCase().trim();

        if (searchTerm.length < 2) {
          searchResults.style.display = "none";
          return;
        }

        // Split search term into individual words for multi-word matching
        const searchWords = searchTerm
          .split(/\s+/)
          .filter((word) => word.length > 0);

        const matches = allModels.filter((model) => {
          // Create searchable text combining all fields INCLUDING make description
          const searchableText =
            `${model.class} ${model.make} ${model.make_desc} ${model.model} ${model.model_desc}`.toLowerCase();

          // Check if all search words are present in the searchable text
          const matchesAllWords = searchWords.every((word) =>
            searchableText.includes(word)
          );

          // Also check individual field matches for more precise results
          const classMatch = model.class.toLowerCase().includes(searchTerm);
          const makeMatch = model.make.toLowerCase().includes(searchTerm);
          const makeDescMatch = model.make_desc
            .toLowerCase()
            .includes(searchTerm);
          const modelMatch = model.model.toLowerCase().includes(searchTerm);
          const descMatch = model.model_desc.toLowerCase().includes(searchTerm);

          // Return true if matches all words OR matches any individual field
          return (
            matchesAllWords ||
            classMatch ||
            makeMatch ||
            makeDescMatch ||
            modelMatch ||
            descMatch
          );
        });

        if (matches.length === 0) {
          searchResults.innerHTML =
            '<div class="no-results">No equipment found</div>';
          searchResults.style.display = "block";
          return;
        }

        // Sort matches by relevance - use ORIGINAL text, not highlighted
        const sortedMatches = matches.sort((a, b) => {
          // Exact matches get highest priority
          const aExactModel = a.model.toLowerCase() === searchTerm;
          const bExactModel = b.model.toLowerCase() === searchTerm;
          if (aExactModel && !bExactModel) return -1;
          if (!aExactModel && bExactModel) return 1;

          // Model code starts with search term
          const aStartsModel = a.model.toLowerCase().startsWith(searchTerm);
          const bStartsModel = b.model.toLowerCase().startsWith(searchTerm);
          if (aStartsModel && !bStartsModel) return -1;
          if (!aStartsModel && bStartsModel) return 1;

          // Class matches - use original text
          const aClassMatch = a.class.toLowerCase().includes(searchTerm);
          const bClassMatch = b.class.toLowerCase().includes(searchTerm);
          if (aClassMatch && !bClassMatch) return -1;
          if (!aClassMatch && bClassMatch) return 1;

          // Make matches (code or description) - use original text
          const aMakeMatch =
            a.make.toLowerCase().includes(searchTerm) ||
            a.make_desc.toLowerCase().includes(searchTerm);
          const bMakeMatch =
            b.make.toLowerCase().includes(searchTerm) ||
            b.make_desc.toLowerCase().includes(searchTerm);
          if (aMakeMatch && !bMakeMatch) return -1;
          if (!aMakeMatch && bMakeMatch) return 1;

          // Alphabetical by class, then make, then model
          const classCompare = a.class.localeCompare(b.class);
          if (classCompare !== 0) return classCompare;

          const makeCompare = a.make.localeCompare(b.make);
          if (makeCompare !== 0) return makeCompare;

          return a.model.localeCompare(b.model);
        });

        // Limit results to 50 items
        const limitedMatches = sortedMatches.slice(0, 50);

        searchResults.innerHTML = limitedMatches
          .map((model) => {
            // Highlight matching text - only apply to display, not to data
            const highlightText = (text) => {
              if (!text) return "";

              // Highlight each search word without adding extra spaces
              let highlighted = String(text);
              searchWords.forEach((word) => {
                const regex = new RegExp(`(${word})`, "gi");
                highlighted = highlighted.replace(
                  regex,
                  '<mark style="background-color: var(--faded-yellow); font-weight: 600;">$1</mark>'
                );
              });

              return highlighted;
            };

            // Format rate with exactly 2 decimal places
            const formatRate = (rate) => {
              if (rate === "N/A" || rate === null || rate === undefined) {
                return "N/A";
              }
              const numValue = parseFloat(rate);
              if (isNaN(numValue)) {
                return "N/A";
              }
              return `$${numValue.toFixed(2)}`;
            };

            // Build the make line without extra spaces
            const makeDescPart = model.make_desc
              ? ` - ${highlightText(model.make_desc)}`
              : "";

            return `
                <div class="search-result-item" data-class="${
                  model.class
                }" data-make="${model.make}" data-model="${model.model}">
                  <div class="search-result-class">${highlightText(
                    model.class
                  )}</div>
                  <div class="search-result-make">${highlightText(
                    model.make
                  )}${makeDescPart}</div>
                  <div class="search-result-model">${highlightText(
                    model.model
                  )} - ${highlightText(model.model_desc)}</div>
                  <div style="font-size: 0.7rem; color: #888; margin-top: 0.25rem;">
                    Rate: ${formatRate(model.rental_rate)}
                  </div>
                </div>
              `;
          })
          .join("");

        searchResults.style.display = "block";

        // Add click handlers to search results
        document.querySelectorAll(".search-result-item").forEach((item) => {
          item.addEventListener("click", function () {
            const equipment = {
              class: this.dataset.class,
              make: this.dataset.make,
              model: this.dataset.model,
              model_desc: allModels.find(
                (m) =>
                  m.class === this.dataset.class &&
                  m.make === this.dataset.make &&
                  m.model === this.dataset.model
              )?.model_desc,
              rental_rate: allModels.find(
                (m) =>
                  m.class === this.dataset.class &&
                  m.make === this.dataset.make &&
                  m.model === this.dataset.model
              )?.rental_rate,
              rate_type: "N",
              expire_date: allModels.find(
                (m) =>
                  m.class === this.dataset.class &&
                  m.make === this.dataset.make &&
                  m.model === this.dataset.model
              )?.expire_date,
              rw_delay: allModels.find(
                (m) =>
                  m.class === this.dataset.class &&
                  m.make === this.dataset.make &&
                  m.model === this.dataset.model
              )?.rw_delay,
              overtime: allModels.find(
                (m) =>
                  m.class === this.dataset.class &&
                  m.make === this.dataset.make &&
                  m.model === this.dataset.model
              )?.overtime,
            };

            addEquipmentToList(equipment);
            modelSearch.value = "";
            searchResults.style.display = "none";
          });
        });
      });

      // Close search results when clicking outside
      document.addEventListener("click", function (e) {
        if (
          !modelSearch.contains(e.target) &&
          !searchResults.contains(e.target)
        ) {
          searchResults.style.display = "none";
        }
      });

      // Close search results on Escape key
      modelSearch.addEventListener("keydown", function (e) {
        if (e.key === "Escape") {
          searchResults.style.display = "none";
          this.blur();
        }
      });
    </script>
  </body>
</html>
